// src/services/NotificationService.js
// @ts-check

const auditLogger = require("../utils/auditLogger");
const { saveDb, updateDb, removeDb } = require("../utils/dbUtils/dbActions");

class NotificationService {
  constructor() {
    this.notificationRepository = null;
  }

  async initialize() {
    const { AppDataSource } = require("../main/db/datasource");
    const Notification = require("../entities/Notification");

    if (!AppDataSource.isInitialized) {
      await AppDataSource.initialize();
    }
    this.notificationRepository = AppDataSource.getRepository(Notification);
    console.log("NotificationService initialized");
  }

  async getRepository() {
    if (!this.notificationRepository) {
      await this.initialize();
    }
    return this.notificationRepository;
  }

  /**
   * Create a new notification (autoâ€‘generated by backend)
   * @param {Object} data - { userId, title, message, type?, metadata? }
   * @param {string} [user="system"] - Who triggered the creation
   */
  async create(data, user = "system") {
    const repo = await this.getRepository();

    try {
      // @ts-ignore
      const notification = repo.create({
        // @ts-ignore
        userId: data.userId,
        // @ts-ignore
        title: data.title,
        // @ts-ignore
        message: data.message,
        // @ts-ignore
        type: data.type || "info",
        // @ts-ignore
        metadata: data.metadata || null,
        isRead: false,
        createdAt: new Date(),
      });

      // @ts-ignore
      const saved = await saveDb(repo, notification);
      await auditLogger.logCreate("Notification", saved.id, saved, user);
      console.log(
        // @ts-ignore
        `Notification created for user ${data.userId}: ${data.title}`,
      );
      return saved;
    } catch (error) {
      // @ts-ignore
      console.error("Failed to create notification:", error.message);
      throw error;
    }
  }

  /**
   * Get a notification by ID
   * @param {number} id
   * @param {number} [userId] - Optional user ID for access control
   */
  // @ts-ignore
  async findById(id, userId = null) {
    const repo = await this.getRepository();

    const where = { id };
    // @ts-ignore
    if (userId !== null) where.userId = userId;

    // @ts-ignore
    const notification = await repo.findOne({ where });
    if (!notification) {
      throw new Error(`Notification with ID ${id} not found`);
    }
    // @ts-ignore
    await auditLogger.logView("Notification", id, "system");
    return notification;
  }

  /**
   * Find all notifications for a user with filters and pagination
   * @param {number} userId
   * @param {Object} options - { isRead?, limit?, offset?, sortBy?, sortOrder? }
   */
  async findAll(userId, options = {}) {
    const repo = await this.getRepository();

    // @ts-ignore
    const queryBuilder = repo
      .createQueryBuilder("notification")
      .where("notification.userId = :userId", { userId });

    // @ts-ignore
    if (options.isRead !== undefined) {
      queryBuilder.andWhere("notification.isRead = :isRead", {
        // @ts-ignore
        isRead: options.isRead,
      });
    }

    // @ts-ignore
    const sortBy = options.sortBy || "createdAt";
    // @ts-ignore
    const sortOrder = options.sortOrder === "ASC" ? "ASC" : "DESC";
    queryBuilder.orderBy(`notification.${sortBy}`, sortOrder);

    // @ts-ignore
    if (options.limit) {
      // @ts-ignore
      queryBuilder.take(options.limit);
    }
    // @ts-ignore
    if (options.offset) {
      // @ts-ignore
      queryBuilder.skip(options.offset);
    }

    const notifications = await queryBuilder.getMany();
    await auditLogger.logView("Notification", null, "system");
    return notifications;
  }

  /**
   * Mark a single notification as read (or unread)
   * @param {number} id
   * @param {boolean} [isRead=true]
   * @param {number} [userId] - Optional user ID for access control
   * @param {string} [user="system"]
   */
  // @ts-ignore
  async markAsRead(id, isRead = true, userId = null, user = "system") {
    const repo = await this.getRepository();

    const where = { id };
    // @ts-ignore
    if (userId !== null) where.userId = userId;

    // @ts-ignore
    const notification = await repo.findOne({ where });
    if (!notification) {
      throw new Error(`Notification with ID ${id} not found`);
    }

    const oldData = { ...notification };
    notification.isRead = isRead;
    notification.updatedAt = new Date();

    // @ts-ignore
    const saved = await updateDb(repo, notification);
    await auditLogger.logUpdate("Notification", id, oldData, saved, user);
    console.log(`Notification ${id} marked as ${isRead ? "read" : "unread"}`);
    return saved;
  }

  /**
   * Mark all notifications for a user as read
   * @param {number} userId
   * @param {string} [user="system"]
   */
  async markAllAsRead(userId, user = "system") {
    const repo = await this.getRepository();

    // @ts-ignore
    const result = await repo
      .createQueryBuilder()
      .update()
      .set({ isRead: true, updatedAt: new Date() })
      .where("userId = :userId AND isRead = :isRead", {
        userId,
        isRead: false,
      })
      .execute();

    const count = result.affected || 0;
    if (count > 0) {
      await auditLogger.logUpdate(
        "Notification",
        null,
        { userId, isRead: false },
        { userId, isRead: true },
        user,
      );
      console.log(`Marked ${count} notifications as read for user ${userId}`);
    }
    return count;
  }

  /**
   * Delete a notification (hard delete)
   * @param {number} id
   * @param {number} [userId] - Optional user ID for access control
   * @param {string} [user="system"]
   */
  // @ts-ignore
  async delete(id, userId = null, user = "system") {
    const repo = await this.getRepository();

    const where = { id };
    // @ts-ignore
    if (userId !== null) where.userId = userId;

    // @ts-ignore
    const notification = await repo.findOne({ where });
    if (!notification) {
      throw new Error(`Notification with ID ${id} not found`);
    }

    // @ts-ignore
    await removeDb(repo, notification);
    await auditLogger.logDelete("Notification", id, notification, user);
    console.log(`Notification ${id} deleted`);
    return { success: true };
  }

  /**
   * Get unread count for a user
   * @param {number} userId
   */
  async getUnreadCount(userId) {
    const repo = await this.getRepository();
    // @ts-ignore
    return repo.count({ where: { userId, isRead: false } });
  }

  /**
   * Get notification statistics for a user
   * @param {number} userId
   */
  async getStats(userId) {
    const repo = await this.getRepository();

    // @ts-ignore
    const total = await repo.count({ where: { userId } });
    // @ts-ignore
    const unread = await repo.count({ where: { userId, isRead: false } });
    const read = total - unread;

    // Count by type (optional)
    // @ts-ignore
    const typeCounts = await repo
      .createQueryBuilder("notification")
      .select("notification.type", "type")
      .addSelect("COUNT(*)", "count")
      .where("notification.userId = :userId", { userId })
      .groupBy("notification.type")
      .getRawMany();

    return {
      total,
      unread,
      read,
      byType: typeCounts.reduce((acc, row) => {
        acc[row.type] = parseInt(row.count, 10);
        return acc;
      }, {}),
    };
  }
}

// Singleton instance
const notificationService = new NotificationService();
module.exports = notificationService;
